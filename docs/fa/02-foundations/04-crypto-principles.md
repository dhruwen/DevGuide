رمزنگاری برای حفظ محرمانگی (Confidentiality) و یکپارچگی (Integrity) اپلیکیشن‌ها و سیستم‌ها به شدت
مهم و اساسی است. [مجموعه برگه‌های تقلب OWASP](https://cheatsheetseries.owasp.org/) کاربرد رمزنگاری را
تشریح می‌کند که برخی از آن‌ها در بخش مطالعه بیشتر در انتهای این متن فهرست شده‌اند.

#### نمای کلی

این بخش مقدمه‌ای کوتاه بر رمزنگاری (که اغلب به سادگی «کریپتو یا سایفر» نامیده می‌شود) و اصطلاحات
مورد استفاده در آن ارائه می‌دهد. رمزنگاری موضوعی بزرگ است و می‌تواند بسیار ریاضیاتی شود، اما خوشبختانه
برای اکثر تیم‌های توسعه، درک کلی از مفاهیم کافی است. این درک عمومی، با راهنمایی معماران امنیت، باید
به تیم توسعه اجازه دهد تا رمزنگاری را برای اپلیکیشن یا سیستم پیاده‌سازی کند.

#### کاربردهای رمزنگاری

اگرچه رمزنگاری در ابتدا عمدتاً به حوزه نظامی و دانشگاهی محدود بود، اما اکنون برای امن‌سازی اپلیکیشن‌های
نرم‌افزاری همه‌گیر شده است. کاربردهای روزمره و رایج رمزنگاری شامل تلفن‌های همراه، رمزهای عبور، SSL VPNها،
کارت‌های هوشمند و DVDها می‌شود. رمزنگاری در زندگی روزمره نفوذ کرده و توسط بسیاری از اپلیکیشن‌های وب به
طور گسترده استفاده می‌شود.

رمزنگاری یکی از موضوعات پیشرفته‌تر در امنیت اطلاعات است و درک آن به بیشترین میزان آموزش و تجربه نیاز دارد.
پیاده‌سازی صحیح آن دشوار است زیرا رویکردهای زیادی برای رمزگذاری وجود دارد که هر کدام مزایا و معایبی
دارند که باید توسط معمارانی که راهکارهای امنیتی را تدوین می‌کنند به طور کامل درک شوند.

پیاده‌سازی صحیح و دقیق رمزنگاری برای کارایی آن بسیار حیاتی است. یک اشتباه کوچک در پیکربندی یا کدنویسی
منجر به از بین رفتن بخش عمده‌ای از حفاظت شده و پیاده‌سازی رمزنگاری را بی‌فایده می‌کند.

درک خوب از کریپتو برای تشخیص بین محصولات معتبر و محصولات بی‌ارزش (snake oil) لازم است. پیچیدگی ذاتی
کریپتو باعث می‌شود به راحتی فریب ادعاهای خارق‌العاده فروشندگان درباره محصولاتشان را بخورید. معمولاً،
این ادعاها شامل «یک پیشرفت شگرف در رمزنگاری»، «غیرقابل شکستن» یا ارائه امنیت «در سطح نظامی» هستند.
اگر یک فروشنده بگوید «به ما اعتماد کنید، کارشناسان ما این را بررسی کرده‌اند»، به احتمال زیاد آن‌ها
کارشناس نبوده‌اند!

#### محرمانگی (Confidentiality)

برای اهداف این بخش، محرمانگی به عنوان «عدم افشای غیرمجاز اطلاعات» تعریف می‌شود. رمزنگاری از طریق
رمزگذاری داده‌ها در حالت سکون (data at rest) یا داده‌ها در حال انتقال (data in transit) به این موضوع
می‌پردازد و اطلاعات را در برابر همه کسانی که کلید رمزگشایی را ندارند، محافظت می‌کند. از هش‌های
رمزنگاری (هش‌های امن و یک‌طرفه) برای جلوگیری از افشای رمزهای عبور استفاده می‌شود.

#### احراز هویت (Authentication)

احراز هویت فرآیند تأیید ادعای یک فاعل (subject) مبنی بر اینکه او همان کسی است که می‌گوید، از طریق
شواهد تأییدکننده ارائه شده است. رمزنگاری در احراز هویت نقش محوری دارد:

1.  برای محافظت از شواهد تأییدکننده ارائه شده (به عنوان مثال، هش کردن رمزهای عبور برای ذخیره‌سازی بعدی).
2.  در پروتکل‌های احراز هویت که اغلب از رمزنگاری برای احراز هویت مستقیم موجودیت‌ها یا تبادل امن اعتبارنامه‌ها
    استفاده می‌کنند.
3.  برای تأیید هویت یک یا هر دو طرف در تبادل پیام‌ها, به عنوان مثال تأیید هویت در امنیت لایه انتقال (TLS).

OpenID Connect به طور گسترده به عنوان یک لایه هویتی بر روی پروتکل OAuth 2.0 استفاده می‌شود. به
[برگه تقلب پروتکل OAuth 2.0](https://cheatsheetseries.owasp.org/cheatsheets/OAuth_2.0_Cheat_Sheet.html) مراجعه کنید.

#### یکپارچگی (Integrity)

یکپارچگی تضمین می‌کند که حتی کاربران مجاز نیز هیچ‌گونه تغییر تصادفی یا مخربی در اطلاعات ایجاد نکرده‌اند.
می‌توان از رمزنگاری برای جلوگیری از دستکاری به وسیله کدهای احراز هویت پیام (MACs) یا امضاهای دیجیتال
استفاده کرد.

اصطلاح «اصالت پیام» (message authenticity) به تضمین یکپارچگی اطلاعات، اغلب با استفاده از رمزنگاری
متقارن و کلیدهای مشترک، اشاره دارد اما هویت فرستنده را احراز نمی‌کند.

اصطلاح «رمزنگاری احراز هویت شده» (authenticated encryption) نیز یکپارچگی اطلاعات را تضمین می‌کند و اگر
از رمزنگاری نامتقارن استفاده شود، می‌تواند فرستنده را نیز احراز هویت کند.

#### عدم انکار (Non-repudiation)

عدم انکار فرستنده تضمین می‌کند که شخصی که پیامی را ارسال می‌کند، نتواند بعداً ارسال آن را انکار کند.
عدم انکار گیرنده به این معناست که گیرنده یک پیام نتواند دریافت آن را انکار کند. می‌توان از رمزنگاری
برای ارائه عدم انکار از طریق پیام‌ها یا پاسخ‌های غیرقابل جعل استفاده کرد.

عدم انکار برای تبادلات مالی، تجارت الکترونیک و قراردادها مفید است. این کار می‌تواند با امضای دیجیتالی
یک رکورد تراکنش منحصر به فرد توسط فرستنده یا گیرنده انجام شود.

#### گواهی‌دهی (Attestation)

گواهی‌دهی عمل «شهادت دادن» یا تأیید چیزی برای یک کاربرد یا هدف خاص است. گواهی‌دهی به طور کلی در زمینه
ماژول پلتفرم مورد اعتماد (TPM)، مدیریت حقوق دیجیتال (DRM) و بوت امن UEFI مورد بحث قرار می‌گیرد.

به عنوان مثال، مدیریت حقوق دیجیتال به گواهی این موضوع علاقه‌مند است که دستگاه یا سیستم شما با یک در پشتی
(back-door) که به کسی اجازه کپی غیرقانونی محتوای محافظت‌شده با DRM را می‌دهد، به خطر نیفتاده باشد.

می‌توان از رمزنگاری برای ارائه زنجیره‌ای از شواهد مبنی بر اینکه همه چیز همانطور که انتظار می‌رود است،
تا به یک چالشگر ثابت شود که همه چیز مطابق با انتظارات اوست. به عنوان مثال، می‌توان از گواهی‌دهی از
راه دور برای اثبات به یک چالشگر استفاده کرد که شما واقعاً در حال اجرای نرم‌افزاری هستید که ادعا
می‌کنید. اغلب گواهی‌دهی با ارائه زنجیره‌ای از امضاهای دیجیتال که با یک بوت لودر مورد اعتماد (امضا
شده دیجیتالی) شروع می‌شود، انجام می‌گردد.

#### هش‌های رمزنگاری

هش‌های رمزنگاری که به آن‌ها خلاصه‌ی پیام (message digests) نیز گفته می‌شود، توابعی هستند که رشته‌های
بیتی با طول دلخواه را به یک رشته بیتی با طول ثابت به نام «مقدار هش» یا «مقدار خلاصه» نگاشت می‌کنند.
این توابع هش، نگاشت‌های چند به یک هستند که توابع فشرده‌سازی محسوب می‌شوند.

توابع هش رمزنگاری برای تأمین یکپارچگی داده‌ها (یعنی شناسایی دستکاری عمدی داده‌ها)، ذخیره رمزهای عبور
یا عبارات عبور و ارائه امضاهای دیجیتال به روشی کارآمدتر از رمزهای نامتقارن استفاده می‌شوند. توابع هش
رمزنگاری همچنین برای گسترش مقدار نسبتاً کوچکی از آنتروپی استفاده می‌شوند تا بتوان مولدهای اعداد تصادفی
امن ساخت.

هنگامی که برای تأمین یکپارچگی داده‌ها استفاده می‌شوند، توابع رمزنگاری دو نوع یکپارچگی را فراهم می‌کنند:
هش‌های کلیددار که اغلب «کدهای احراز هویت پیام» نامیده می‌شوند و هش‌های بدون کلید که «کدهای یکپارچگی
پیام» نامیده می‌شوند.

#### رمزها (Ciphers)

رمز (Cipher) الگوریتمی است که رمزگذاری یا رمزگشایی را انجام می‌دهد. رمزهای مدرن را می‌توان به چند
روش مختلف دسته‌بندی کرد. رایج‌ترین تمایز بین آنها عبارتند از:

* اینکه آیا روی تعداد ثابتی از بیت‌ها کار می‌کنند (رمزهای قالبی یا block ciphers) یا روی یک جریان
  پیوسته از بیت‌ها (رمزهای جریانی یا stream ciphers).
* اینکه آیا از کلید یکسانی برای رمزگذاری و رمزگشایی استفاده می‌شود (رمزهای متقارن یا symmetric ciphers)
  یا از کلیدهای جداگانه برای رمزگذاری و رمزگشایی (رمزهای نامتقارن یا asymmetric ciphers).

#### رمزهای متقارن (Symmetric Ciphers)

رمزهای متقارن با استفاده از یک کلید یکسان، رمزگذاری و رمزگشایی می‌کنند. این بدان معناست که اگر یک طرف
داده‌ها را رمزگذاری کند و طرف دیگر باید آن را رمزگشایی کند، آن دو طرف باید یک کلید مشترک داشته باشند.

رمزهای متقارن دو نوع اصلی دارند:

1.  رمزهای قالبی (Block ciphers)، که هر بار روی یک بلوک از کاراکترها (معمولاً ۸ یا ۱۶ اکتت) عمل می‌کنند.
    نمونه‌ای از رمز قالبی، AES است.
2.  رمزهای جریانی (Stream ciphers)، که هر بار روی یک بیت (یا گاهی یک بایت) عمل می‌کنند. نمونه‌هایی از
    رمزهای جریانی RC4 (معروف به ARC4) و Salsa20 هستند.

توجه داشته باشید که تمام رمزهای قالبی با انتخاب حالت رمز مناسب می‌توانند در «حالت جریانی» نیز عمل کنند.

#### حالت‌های رمز (Cipher Modes)

رمزهای قالبی می‌توانند در حالت‌های عملیاتی مختلفی به نام «حالت‌های رمز» کار کنند. این حالت رمز به
صورت الگوریتمی نحوه عملکرد یک رمز را برای اعمال مکرر مکانیزم رمزگذاری یا رمزگشایی خود بر روی یک
بلوک رمز معین توصیف می‌کند. حالت‌های رمز مهم هستند زیرا تأثیر بسیار زیادی بر محرمانگی و اصالت پیام
متن‌های رمز شده حاصل دارند.

تقریباً تمام کتابخانه‌های رمزنگاری از چهار حالت رمز اصلی DES یعنی ECB، CBC (زنجیره‌سازی بلوک رمز)،
OFB (بازخورد خروجی) و CFB (بازخورد رمز) پشتیبانی می‌کنند. بسیاری نیز از حالت CTR (شمارنده)
پشتیبانی می‌کنند.

#### بردار اولیه (Initialization vector)

بردار اولیه رمزنگاری (IV) یک ورودی با اندازه ثابت برای تابع اولیه رمزگذاری / رمزگشایی یک رمز قالبی است.
توصیه می‌شود (و در بسیاری موارد، الزامی است) که IV تصادفی یا حداقل شبه تصادفی باشد.

#### ایجاد فاصله (Padding)

رمزهای قالبی، به جز زمانی که در حالت جریانی کار می‌کنند، معمولاً روی بلوک‌هایی با اندازه ثابت عمل
می‌کنند. این رمزهای قالبی باید بتوانند روی پیام‌هایی با هر اندازه‌ای نیز کار کنند، نه فقط آنهایی که
مضرب صحیحی از اندازه بلوک رمز هستند، و بنابراین می‌توان پیام را فاصله‌گذاری (padded) کرد تا در
بلوک بعدی با اندازه ثابت قرار گیرد.

#### رمزهای نامتقارن (Asymmetric ciphers)

رمزهای نامتقارن با دو کلید متفاوت رمزگذاری و رمزگشایی می‌کنند. یک کلید معمولاً به عنوان کلید خصوصی و
دیگری به عنوان کلید عمومی تعیین می‌شود. به طور کلی، کلید عمومی به طور گسترده به اشتراک گذاشته می‌شود
و کلید خصوصی امن نگه داشته می‌شود.

رمزهای نامتقارن چندین برابر کندتر از رمزهای متقارن هستند. به همین دلیل، آنها اغلب در سیستم‌های رمزنگاری
ترکیبی (hybrid cryptosystems) که رمزهای نامتقارن و متقارن را ترکیب می‌کنند، استفاده می‌شوند. در چنین
سیستم‌های ترکیبی، یک کلید جلسه متقارن تصادفی تولید می‌شود که فقط برای مدت زمان ارتباط رمزگذاری شده
استفاده می‌شود. سپس این کلید جلسه تصادفی با استفاده از یک رمز نامتقارن و کلید خصوصی گیرنده رمزگذاری
می‌شود. داده‌های متنی ساده (plaintext) خود با کلید جلسه رمزگذاری می‌شوند. سپس کل بسته (کلید جلسه
رمزگذاری شده و پیام رمزگذاری شده) با هم ارسال می‌شود.

هر دو TLS و S/MIME سیستم‌های رمزنگاری رایجی هستند که از رمزنگاری ترکیبی استفاده می‌کنند.

#### امضای دیجیتال (Digital signature)

امضاهای دیجیتال یک رشته داده منحصر به فرد رمزنگاری شده هستند که برای تضمین یکپارچگی داده‌ها، اثبات
اصالت یک پیام دیجیتال و مرتبط کردن یک پیام ورودی با یک موجودیت مبدأ استفاده می‌شوند. الگوریتم تولید
امضای دیجیتال یک الگوریتم قوی رمزنگاری است که برای تولید امضای دیجیتال استفاده می‌شود.

#### پروتکل توافق کلید (Key agreement protocol)

پروتکل‌های توافق کلید، پروتکل‌هایی هستند که به وسیله آنها N طرف (معمولاً دو طرف) می‌توانند بر روی
یک کلید مشترک بدون تبادل واقعی کلید به توافق برسند. در صورت طراحی و پیاده‌سازی صحیح، پروتکل‌های توافق
کلید از یادگیری کلید توسط دشمنان یا تحمیل انتخاب کلید خودشان بر طرف‌های شرکت‌کننده جلوگیری می‌کنند.

#### رمزگذاری در سطح اپلیکیشن (Application level encryption)

رمزگذاری در سطح اپلیکیشن به رمزگذاری‌ای اطلاق می‌شود که بخشی از خود اپلیکیشن در نظر گرفته می‌شود؛ این
موضوع هیچ چیزی را در مورد اینکه رمزگذاری واقعاً در کجای کد اپلیکیشن انجام می‌شود، بیان نمی‌کند.

#### استخراج کلید (Key derivation)

تابع استخراج کلید (KDF) یک الگوریتم قطعی برای استخراج یک کلید با اندازه معین از یک مقدار مخفی است.
اگر دو طرف از یک مقدار مخفی مشترک و یک KDF یکسان استفاده کنند، باید همیشه دقیقاً همان کلید را استخراج کنند.

#### پوشش کلید (Key wrapping)

پوشش کلید، ساختاری است که با رمزهای متقارن برای محافظت از مواد کلید رمزنگاری از طریق رمزگذاری آن به
روشی خاص استفاده می‌شود. الگوریتم‌های پوشش کلید برای محافظت از کلیدها در حین نگهداری در حافظه غیرقابل
اعتماد یا هنگام انتقال کلیدها از طریق شبکه‌های ارتباطی ناامن در نظر گرفته شده‌اند.

#### الگوریتم‌های تبادل کلید (Key exchange algorithms)

الگوریتم‌های تبادل کلید (که به آنها الگوریتم‌های ایجاد کلید نیز گفته می‌شود) پروتکل‌هایی هستند که برای
تبادل کلیدهای رمزنگاری مخفی بین فرستنده و گیرنده به روشی که محدودیت‌های امنیتی خاصی را برآورده کند،
استفاده می‌شوند. الگوریتم‌های تبادل کلید سعی در حل مشکل به اشتراک‌گذاری امن یک کلید مخفی مشترک با دو
طرف از طریق یک کانال ارتباطی ناامن به گونه‌ای دارند که هیچ طرف دیگری نتواند به نسخه‌ای از کلید مخفی
دسترسی پیدا کند.

آشناترین الگوریتم تبادل کلید، تبادل کلید دیفی-هلمن است. الگوریتم‌های تبادل کلید احراز هویت شده با
رمز عبور نیز وجود دارند. تبادل کلید RSA با استفاده از PKI یا وب‌های اعتماد یا سرورهای کلید مورد
اعتماد نیز به طور رایج استفاده می‌شوند.

#### پروتکل‌های انتقال کلید (Key transport protocols)

پروتکل‌های انتقال کلید پروتکل‌هایی هستند که در آنها یک طرف کلید را تولید کرده و آن را به طور امن برای
گیرنده(ها) ارسال می‌کند.

#### پروتکل‌های توافق کلید (Key agreement protocols)

پروتکل‌های توافق کلید پروتکل‌هایی هستند که به وسیله آنها N طرف (معمولاً دو طرف) می‌توانند بر روی یک
کلید مشترک به توافق برسند در حالی که همه طرف‌ها در مقدار کلید مشارکت دارند. این پروتکل‌ها از یادگیری
کلید توسط دشمنان یا تحمیل انتخاب کلید خودشان بر طرف‌های شرکت‌کننده جلوگیری می‌کنند.

#### منابع (References)

* مجموعه Cheat Sheetهای OWASP
  * [Authentication](https://cheatsheetseries.owasp.org/cheatsheets/Authentication_Cheat_Sheet.html)
  * [Authorization](https://cheatsheetseries.owasp.org/cheatsheets/Authorization_Cheat_Sheet.html)
  * [Cryptographic Storage](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)
  * [Key Management](https://cheatsheetseries.owasp.org/cheatsheets/Key_Management_Cheat_Sheet.html)
  * [OAuth 2.0 Protocol](https://cheatsheetseries.owasp.org/cheatsheets/OAuth_2.0_Cheat_Sheet.html)
  * [SAML Security](https://cheatsheetseries.owasp.org/cheatsheets/SAML_Security_Cheat_Sheet.html)
  * [Secure Product Design](https://cheatsheetseries.owasp.org/cheatsheets/Secure_Product_Design_Cheat_Sheet.html)
  * [User Privacy Protection](https://cheatsheetseries.owasp.org/cheatsheets/User_Privacy_Protection_Cheat_Sheet.html)

---

راهنمای توسعه‌دهندگان OWASP یک تلاش جمعی است؛ اگر چیزی نیاز به تغییر دارد، لطفاً
[یک issue ثبت کنید](https://github.com/OWASP/DevGuide/issues/new?labels=enhancement&template=request.md&title=Update:%2002-foundations/04-crypto-principles)
یا [در GitHub ویرایش کنید](https://github.com/OWASP/DevGuide/blob/main/docs/en/02-foundations/04-crypto-principles.md).